"use strict";(self.webpackChunkhertzbeat=self.webpackChunkhertzbeat||[]).push([[10730],{15680:(e,t,r)=>{r.d(t,{xA:()=>s,yg:()=>u});var n=r(96540);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var p=n.createContext({}),c=function(e){var t=n.useContext(p),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},s=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),g=c(r),u=a,d=g["".concat(p,".").concat(u)]||g[u]||m[u]||o;return r?n.createElement(d,i(i({ref:t},s),{},{components:r})):n.createElement(d,i({ref:t},s))}));function u(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=g;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}g.displayName="MDXCreateElement"},81910:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=r(58168),a=(r(96540),r(15680));const o={id:"udp_port",title:"Monitoring UDP port availability",sidebar_label:"UDP Port availability",keywords:["open source monitoring tool","open source port monitoring tool","monitoring UDP port metrics"]},i=void 0,l={unversionedId:"help/udp_port",id:"help/udp_port",title:"Monitoring UDP port availability",description:"UDP is a connectionless transport layer protocol. We determine the availability status of its ports by sending request packets at the application layer and receiving responses. The configuration information requires filling in the hexadecimal content of the application layer packets that prompt responses from the peer. We recommend using Wireshark for packet capture to obtain the transmitted packet content.",source:"@site/docs/help/udp_port.md",sourceDirName:"help",slug:"/help/udp_port",permalink:"/docs/help/udp_port",draft:!1,editUrl:"https://github.com/apache/hertzbeat/edit/master/home/docs/help/udp_port.md",tags:[],version:"current",frontMatter:{id:"udp_port",title:"Monitoring UDP port availability",sidebar_label:"UDP Port availability",keywords:["open source monitoring tool","open source port monitoring tool","monitoring UDP port metrics"]},sidebar:"docs",previous:{title:"TCP Port availability",permalink:"/docs/help/port"},next:{title:"Full site Monitor",permalink:"/docs/help/fullsite"}},p={},c=[{value:"Configuration parameter",id:"configuration-parameter",level:3},{value:"Collection Metric",id:"collection-metric",level:3},{value:"Metric set\uff1asummary",id:"metric-setsummary",level:4}],s={toc:c};function m(e){let{components:t,...r}=e;return(0,a.yg)("wrapper",(0,n.A)({},s,r,{components:t,mdxType:"MDXLayout"}),(0,a.yg)("blockquote",null,(0,a.yg)("p",{parentName:"blockquote"},"UDP is a connectionless transport layer protocol. We determine the availability status of its ports by sending request packets at the application layer and receiving responses. The configuration information requires filling in the hexadecimal content of the application layer packets that prompt responses from the peer. We recommend using Wireshark for packet capture to obtain the transmitted packet content.",(0,a.yg)("br",{parentName:"p"}),"\n","You can click on ",(0,a.yg)("inlineCode",{parentName:"p"},"Create UDP Port Availability")," to configure or select ",(0,a.yg)("inlineCode",{parentName:"p"},"More Actions")," to import existing configurations.")),(0,a.yg)("h3",{id:"configuration-parameter"},"Configuration parameter"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Parameter name"),(0,a.yg)("th",{parentName:"tr",align:null},"Parameter help description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Monitoring Host"),(0,a.yg)("td",{parentName:"tr",align:null},"Monitored IPV4, IPV6 or domain name. Note\u26a0\ufe0f Without protocol header (eg: https://, http://).")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Monitoring name"),(0,a.yg)("td",{parentName:"tr",align:null},"Identify the name of this monitoring. The name needs to be unique.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Port"),(0,a.yg)("td",{parentName:"tr",align:null},"Ports provided by website.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Connection timeout"),(0,a.yg)("td",{parentName:"tr",align:null},"The waiting timeout for port connections, in milliseconds. Default is 6000 milliseconds.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Sent Packet Content"),(0,a.yg)("td",{parentName:"tr",align:null},"The hexadecimal content of the application layer packet that prompts a response from the peer.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Collector"),(0,a.yg)("td",{parentName:"tr",align:null},"Specifies which collector to use for scheduling collection for this monitoring.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Collection interval"),(0,a.yg)("td",{parentName:"tr",align:null},"Interval time of monitor periodic data collection, unit: second, and the minimum interval that can be set is 30 seconds.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Bind Tags"),(0,a.yg)("td",{parentName:"tr",align:null},"Classification management tags for monitoring resources.")),(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Description"),(0,a.yg)("td",{parentName:"tr",align:null},"For more information about identifying and describing this monitoring, users can note information here.")))),(0,a.yg)("h3",{id:"collection-metric"},"Collection Metric"),(0,a.yg)("h4",{id:"metric-setsummary"},"Metric set\uff1asummary"),(0,a.yg)("table",null,(0,a.yg)("thead",{parentName:"table"},(0,a.yg)("tr",{parentName:"thead"},(0,a.yg)("th",{parentName:"tr",align:null},"Metric name"),(0,a.yg)("th",{parentName:"tr",align:null},"Metric unit"),(0,a.yg)("th",{parentName:"tr",align:null},"Metric help description"))),(0,a.yg)("tbody",{parentName:"table"},(0,a.yg)("tr",{parentName:"tbody"},(0,a.yg)("td",{parentName:"tr",align:null},"Response Time"),(0,a.yg)("td",{parentName:"tr",align:null},"Milliseconds (ms)"),(0,a.yg)("td",{parentName:"tr",align:null},"Website response time")))))}m.isMDXComponent=!0}}]);