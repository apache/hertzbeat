"use strict";(globalThis.webpackChunkhertzbeat=globalThis.webpackChunkhertzbeat||[]).push([[46233],{98287(e,t,s){s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>a,frontMatter:()=>n,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"help/hdfs_namenode","title":"Monitoring HDFS NameNode Monitoring","description":"Hertzbeat monitors metrics for HDFS NameNode nodes.","source":"@site/versioned_docs/version-1.8.0/help/hdfs_namenode.md","sourceDirName":"help","slug":"/help/hdfs_namenode","permalink":"/docs/help/hdfs_namenode","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hertzbeat/edit/master/home/versioned_docs/version-1.8.0/help/hdfs_namenode.md","tags":[],"version":"1.8.0","frontMatter":{"id":"hdfs_namenode","title":"Monitoring HDFS NameNode Monitoring","sidebar_label":"Apache HDFS NameNode","keywords":["big data monitoring system","distributed file system monitoring","HDFS NameNode monitoring"]},"sidebar":"docs","previous":{"title":"Apache HDFS DataNode","permalink":"/docs/help/hdfs_datanode"},"next":{"title":"Apache HugeGraph","permalink":"/docs/help/hugegraph"}}');var d=s(86070),i=s(60056);const n={id:"hdfs_namenode",title:"Monitoring HDFS NameNode Monitoring",sidebar_label:"Apache HDFS NameNode",keywords:["big data monitoring system","distributed file system monitoring","HDFS NameNode monitoring"]},c=void 0,l={},o=[{value:"Pre-Monitoring Actions",id:"pre-monitoring-actions",level:2},{value:"Configuration Parameters",id:"configuration-parameters",level:2},{value:"Collected Metrics",id:"collected-metrics",level:3},{value:"Metric Set: FSNamesystem",id:"metric-set-fsnamesystem",level:4},{value:"Metric Set: RPC",id:"metric-set-rpc",level:4},{value:"Metric Set: runtime",id:"metric-set-runtime",level:4},{value:"Metric Set: JvmMetrics",id:"metric-set-jvmmetrics",level:4}];function h(e){const t={blockquote:"blockquote",h2:"h2",h3:"h3",h4:"h4",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(t.blockquote,{children:["\n",(0,d.jsx)(t.p,{children:"Hertzbeat monitors metrics for HDFS NameNode nodes."}),"\n"]}),"\n",(0,d.jsx)(t.p,{children:(0,d.jsx)(t.strong,{children:"Protocol Used: HTTP"})}),"\n",(0,d.jsx)(t.h2,{id:"pre-monitoring-actions",children:"Pre-Monitoring Actions"}),"\n",(0,d.jsx)(t.p,{children:"Ensure that you have obtained the JMX monitoring port for the HDFS NameNode."}),"\n",(0,d.jsx)(t.h2,{id:"configuration-parameters",children:"Configuration Parameters"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Parameter Name"}),(0,d.jsx)(t.th,{children:"Parameter Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Target Host"}),(0,d.jsx)(t.td,{children:"The IPv4, IPv6, or domain name of the target being monitored. Exclude protocol headers."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Port"}),(0,d.jsx)(t.td,{children:"The monitoring port number of the HDFS NameNode, default is 50070."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Query Timeout"}),(0,d.jsx)(t.td,{children:"Timeout for querying the HDFS NameNode, in milliseconds, default is 6000 milliseconds."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Metrics Collection Interval"}),(0,d.jsx)(t.td,{children:"Time interval for collecting monitoring data, in seconds, minimum interval is 30 seconds."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Probe Before Monitoring"}),(0,d.jsx)(t.td,{children:"Whether to probe and check the availability of monitoring before adding it."})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"Description/Remarks"}),(0,d.jsx)(t.td,{children:"Additional description and remarks for this monitoring."})]})]})]}),"\n",(0,d.jsx)(t.h3,{id:"collected-metrics",children:"Collected Metrics"}),"\n",(0,d.jsx)(t.h4,{id:"metric-set-fsnamesystem",children:"Metric Set: FSNamesystem"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Metric Name"}),(0,d.jsx)(t.th,{children:"Metric Unit"}),(0,d.jsx)(t.th,{children:"Metric Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityTotal"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Total cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityTotalGB"}),(0,d.jsx)(t.td,{children:"GB"}),(0,d.jsx)(t.td,{children:"Total cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityUsed"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Used cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityUsedGB"}),(0,d.jsx)(t.td,{children:"GB"}),(0,d.jsx)(t.td,{children:"Used cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityRemaining"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Remaining cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityRemainingGB"}),(0,d.jsx)(t.td,{children:"GB"}),(0,d.jsx)(t.td,{children:"Remaining cluster storage capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CapacityUsedNonDFS"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Non-HDFS usage of cluster capacity"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"TotalLoad"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Total client connections in the cluster"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"FilesTotal"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Total number of files in the cluster"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"BlocksTotal"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Total number of BLOCKs"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"PendingReplicationBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of blocks awaiting replication"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"UnderReplicatedBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of blocks with insufficient replicas"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"CorruptBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of corrupt blocks"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ScheduledReplicationBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of blocks scheduled for replication"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"PendingDeletionBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of blocks awaiting deletion"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ExcessBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of excess blocks"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"PostponedMisreplicatedBlocks"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of misreplicated blocks postponed for processing"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"NumLiveDataNodes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of live data nodes in the cluster"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"NumDeadDataNodes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of data nodes marked as dead"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"NumDecomLiveDataNodes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of decommissioned live nodes"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"NumDecomDeadDataNodes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of decommissioned dead nodes"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"NumDecommissioningDataNodes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of nodes currently being decommissioned"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"TransactionsSinceLastCheckpoint"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of transactions since the last checkpoint"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"LastCheckpointTime"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Time of the last checkpoint"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"PendingDataNodeMessageCount"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Number of DATANODE requests queued in the standby namenode"})]})]})]}),"\n",(0,d.jsx)(t.h4,{id:"metric-set-rpc",children:"Metric Set: RPC"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Metric Name"}),(0,d.jsx)(t.th,{children:"Metric Unit"}),(0,d.jsx)(t.th,{children:"Metric Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ReceivedBytes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Data receiving rate"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"SentBytes"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Data sending rate"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"RpcQueueTimeNumOps"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"RPC call rate"})]})]})]}),"\n",(0,d.jsx)(t.h4,{id:"metric-set-runtime",children:"Metric Set: runtime"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Metric Name"}),(0,d.jsx)(t.th,{children:"Metric Unit"}),(0,d.jsx)(t.th,{children:"Metric Description"})]})}),(0,d.jsx)(t.tbody,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"StartTime"}),(0,d.jsx)(t.td,{}),(0,d.jsx)(t.td,{children:"Start time"})]})})]}),"\n",(0,d.jsx)(t.h4,{id:"metric-set-jvmmetrics",children:"Metric Set: JvmMetrics"}),"\n",(0,d.jsxs)(t.table,{children:[(0,d.jsx)(t.thead,{children:(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.th,{children:"Metric Name"}),(0,d.jsx)(t.th,{children:"Metric Unit"}),(0,d.jsx)(t.th,{children:"Metric Description"})]})}),(0,d.jsxs)(t.tbody,{children:[(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemNonHeapUsedM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Current usage of NonHeapMemory by JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemNonHeapCommittedM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Committed NonHeapMemory by JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemHeapUsedM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Current usage of HeapMemory by JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemHeapCommittedM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Committed HeapMemory by JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemHeapMaxM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Maximum HeapMemory configured for JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"MemMaxM"}),(0,d.jsx)(t.td,{children:"MB"}),(0,d.jsx)(t.td,{children:"Maximum memory that can be used by JVM"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcCountParNew"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of ParNew GC events"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcTimeMillisParNew"}),(0,d.jsx)(t.td,{children:"Milliseconds"}),(0,d.jsx)(t.td,{children:"Time spent in ParNew GC"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcCountConcurrentMarkSweep"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of ConcurrentMarkSweep GC events"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcTimeMillisConcurrentMarkSweep"}),(0,d.jsx)(t.td,{children:"Milliseconds"}),(0,d.jsx)(t.td,{children:"Time spent in ConcurrentMarkSweep GC"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcCount"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Total number of GC events"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"GcTimeMillis"}),(0,d.jsx)(t.td,{children:"Milliseconds"}),(0,d.jsx)(t.td,{children:"Total time spent in GC events"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ThreadsRunnable"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of threads in RUNNABLE state"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ThreadsBlocked"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of threads in BLOCKED state"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ThreadsWaiting"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of threads in WAITING state"})]}),(0,d.jsxs)(t.tr,{children:[(0,d.jsx)(t.td,{children:"ThreadsTimedWaiting"}),(0,d.jsx)(t.td,{children:"Count"}),(0,d.jsx)(t.td,{children:"Number of threads in TIMED WAITING state"})]})]})]})]})}function a(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,d.jsx)(t,{...e,children:(0,d.jsx)(h,{...e})}):h(e)}},60056(e,t,s){s.d(t,{R:()=>n,x:()=>c});var r=s(30758);const d={},i=r.createContext(d);function n(e){const t=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(d):e.components||d:n(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);