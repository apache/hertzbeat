"use strict";(globalThis.webpackChunkhertzbeat=globalThis.webpackChunkhertzbeat||[]).push([[44223],{36615(e,t,r){r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>a,frontMatter:()=>i,metadata:()=>s,toc:()=>h});const s=JSON.parse('{"id":"help/valkey","title":"Monitorin Valkey database","description":"Collect and monitor the general performance Metrics of Valkey database. Support Valkey 7.0+.","source":"@site/versioned_docs/version-1.7.x/help/valkey.md","sourceDirName":"help","slug":"/help/valkey","permalink":"/docs/1.7.x/help/valkey","draft":false,"unlisted":false,"editUrl":"https://github.com/apache/hertzbeat/edit/master/home/versioned_docs/version-1.7.x/help/valkey.md","tags":[],"version":"1.7.x","frontMatter":{"id":"valkey","title":"Monitorin Valkey database","sidebar_label":"Valkey","keywords":["open source monitoring tool","open source valkey monitoring tool","monitoring valkey metrics"]},"sidebar":"docs","previous":{"title":"Memcached Monitor","permalink":"/docs/1.7.x/help/memcached"},"next":{"title":"Linux operating system","permalink":"/docs/1.7.x/help/linux"}}');var n=r(86070),d=r(60056);const i={id:"valkey",title:"Monitorin Valkey database",sidebar_label:"Valkey",keywords:["open source monitoring tool","open source valkey monitoring tool","monitoring valkey metrics"]},c=void 0,l={},h=[{value:"Configuration parameter",id:"configuration-parameter",level:3},{value:"Collection Metric",id:"collection-metric",level:3},{value:"Metric set\uff1aserver",id:"metric-setserver",level:4},{value:"Metric set\uff1aclients",id:"metric-setclients",level:4},{value:"Metric set\uff1amemory",id:"metric-setmemory",level:4},{value:"Metric set\uff1apersistence",id:"metric-setpersistence",level:4},{value:"Metric set\uff1astats",id:"metric-setstats",level:4},{value:"Metric set\uff1areplication",id:"metric-setreplication",level:4},{value:"Metric set\uff1acpu",id:"metric-setcpu",level:4},{value:"Metric set\uff1aerrorstats",id:"metric-seterrorstats",level:4},{value:"Metric set\uff1acluster",id:"metric-setcluster",level:4},{value:"Metric set\uff1acommandstats",id:"metric-setcommandstats",level:4}];function o(e){const t={blockquote:"blockquote",h3:"h3",h4:"h4",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,d.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.blockquote,{children:["\n",(0,n.jsx)(t.p,{children:"Collect and monitor the general performance Metrics of Valkey database. Support Valkey 7.0+."}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"configuration-parameter",children:"Configuration parameter"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Parameter name"}),(0,n.jsx)(t.th,{children:"Parameter help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Target Host"}),(0,n.jsx)(t.td,{children:"The IP, IPV6, or domain name of the monitored endpoint. Note \u26a0\ufe0f: Do not include protocol headers (eg: https://, http://)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Port"}),(0,n.jsx)(t.td,{children:"The HTTP port provided by Valkey, default value is 6379, sentinel node`s default value is 26379"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Timeout"}),(0,n.jsx)(t.td,{children:"Set the timeout time when SQL query does not respond to data, unit: ms, default: 3000ms"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Username"}),(0,n.jsx)(t.td,{children:"Database connection user name, optional"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Password"}),(0,n.jsx)(t.td,{children:"Database connection password, optional"})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"collection-metric",children:"Collection Metric"}),"\n",(0,n.jsx)(t.h4,{id:"metric-setserver",children:"Metric set\uff1aserver"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"valkey_version"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Version of the Valkey server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"valkey_git_sha1"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Git SHA1"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"valkey_git_dirty"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Git dirty flag"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"valkey_build_id"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The build id"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"valkey_mode"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:'The server\'s mode ("standalone", "sentinel" or "cluster")'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"os"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Operating system hosting the Valkey server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"arch_bits"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Architecture (32 or 64 bits)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"multiplexing_api"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Event loop mechanism used by Valkey"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"atomicvar_api"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Atomicvar API used by Valkey"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"gcc_version"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Version of the GCC compiler used to compile the Valkey server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"process_id"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"PID of the server process"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"process_supervised"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:'Supervised system ("upstart", "systemd", "unknown" or "no")'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"run_id"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Random value identifying the Valkey server (to be used by Sentinel and Cluster)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"tcp_port"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"TCP/IP listen port"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"server_time_usec"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Epoch-based system time with microsecond precision"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"uptime_in_seconds"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of seconds since Valkey server start"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"uptime_in_days"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Same value expressed in days"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"hz"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The server's current frequency setting"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"configured_hz"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The server's configured frequency setting"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"lru_clock"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Clock incrementing every minute, for LRU management"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"executable"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The path to the server's executable"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"config_file"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The path to the config file"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"io_threads_active"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating if I/O threads are active"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"shutdown_in_milliseconds"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The maximum time remaining for replicas to catch up the replication before completing the shutdown sequence. This field is only present during shutdown."})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setclients",children:"Metric set\uff1aclients"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"connected_clients"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of client connections (excluding connections from replicas)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cluster_connections"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"An approximation of the number of sockets used by the cluster's bus"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"maxclients"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The value of the maxclients configuration directive. This is the upper limit for the sum of connected_clients, connected_slaves and cluster_connections."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"client_recent_max_input_buffer"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Biggest input buffer among current client connections"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"client_recent_max_output_buffer"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Biggest output buffer among current client connections"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"blocked_clients"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of clients pending on a blocking call (BLPOP, BRPOP, BRPOPLPUSH, BLMOVE, BZPOPMIN, BZPOPMAX)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"tracking_clients"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of clients being tracked (CLIENT TRACKING)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"clients_in_timeout_table"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of clients in the clients timeout table"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setmemory",children:"Metric set\uff1amemory"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Total number of bytes allocated by Valkey using its allocator (either standard libc, jemalloc, or an alternative allocator such as tcmalloc)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_rss"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Number of bytes that Valkey allocated as seen by the operating system (a.k.a resident set size). This is the number reported by tools such as top(1) and ps(1)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_rss_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value\u503c"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_peak"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Peak memory consumed by Valkey (in bytes)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_peak_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_peak_perc"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The percentage of used_memory_peak out of used_memory"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_overhead"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The sum in bytes of all overheads that the server allocated for managing its internal data structures"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_startup"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Initial amount of memory consumed by Valkey at startup in bytes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_dataset"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The size in bytes of the dataset (used_memory_overhead subtracted from used_memory)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_dataset_perc"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The percentage of used_memory_dataset out of the net memory usage (used_memory minus used_memory_startup)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_allocated"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Total bytes allocated form the allocator, including internal-fragmentation. Normally the same as used_memory."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_active"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Total bytes in the allocator active pages, this includes external-fragmentation."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_resident"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Total bytes resident (RSS) in the allocator, this includes pages that can be released to the OS (by MEMORY PURGE, or just waiting)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_system_memory"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The total amount of memory that the Valkey host has"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_system_memory_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_lua"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Number of bytes used by the Lua engine for EVAL scripts. Deprecated in Valkey 7.0, renamed to used_memory_vm_eval"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_lua_human"}),(0,n.jsx)(t.td,{children:"KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value. Deprecated in Valkey 7.0"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_scripts"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"used_memory_scripts_eval + used_memory_functions (part of used_memory). Added in Valkey 7.0"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_memory_scripts_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"number_of_cached_scripts"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of EVAL scripts cached by the server. Added in Valkey 7.0"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"maxmemory"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The value of the maxmemory configuration directive"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"maxmemory_human"}),(0,n.jsx)(t.td,{children:"GB/MB/KB"}),(0,n.jsx)(t.td,{children:"Human readable representation of previous value"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"maxmemory_policy"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The value of the maxmemory-policy configuration directive"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_frag_ratio"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Ratio between allocator_active and allocator_allocated. This is the true (external) fragmentation metric (not mem_fragmentation_ratio)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_frag_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Delta between allocator_active and allocator_allocated. See note about mem_fragmentation_bytes."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_rss_ratio"}),(0,n.jsx)(t.td,{}),(0,n.jsx)(t.td,{children:"Ratio between allocator_resident and allocator_active."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"allocator_rss_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Delta between allocator_resident and allocator_active"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rss_overhead_ratio"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Ratio between used_memory_rss (the process RSS) and allocator_resident. This includes RSS overheads that are not allocator or heap related."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rss_overhead_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Delta between used_memory_rss (the process RSS) and allocator_resident"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_fragmentation_ratio"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Ratio between used_memory_rss and used_memory. Note that this doesn't only includes fragmentation, but also other process overheads (see the allocator_* metrics), and also overheads like code, shared libraries, stack, etc."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_fragmentation_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Delta between used_memory_rss and used_memory. Note that when the total fragmentation bytes is low (few megabytes), a high ratio (e.g. 1.5 and above) is not an indication of an issue."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_not_counted_for_evict"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Used memory that's not counted for key eviction. This is basically transient replica and AOF buffers."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_replication_backlog"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Memory used by replication backlog"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_clients_slaves"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Memory used by replica clients - Starting Valkey 7.0, replica buffers share memory with the replication backlog, so this field can show 0 when replicas don't trigger an increase of memory usage."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_clients_normal"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Memory used by normal clients"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_aof_buffer"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Transient memory used for AOF and AOF rewrite buffers"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"mem_allocator"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Memory allocator, chosen at compile time."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"active_defrag_running"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"When activedefrag is enabled, this indicates whether defragmentation is currently active, and the CPU percentage it intends to utilize."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"lazyfree_pending_objects"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of objects waiting to be freed (as a result of calling UNLINK, or FLUSHDB and FLUSHALL with the ASYNC option)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"lazyfreed_objects"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of objects that have been lazy freed."})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setpersistence",children:"Metric set\uff1apersistence"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"loading"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating if the load of a dump file is on-going"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"current_cow_size"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The size in bytes of copy-on-write memory while a child fork is running"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"current_cow_size_age"}),(0,n.jsx)(t.td,{children:"second"}),(0,n.jsx)(t.td,{children:"The age, in seconds, of the current_cow_size value."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"current_fork_perc"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The percentage of progress of the current fork process. For AOF and RDB forks it is the percentage of current_save_keys_processed out of"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"current_save_keys_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of keys processed by the current save operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"current_save_keys_total"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of keys at the beginning of the current save operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_changes_since_last_save"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of changes since the last dump"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_bgsave_in_progress"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating a RDB save is on-going"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_last_save_time"}),(0,n.jsx)(t.td,{children:"second"}),(0,n.jsx)(t.td,{children:"Epoch-based timestamp of last successful RDB save"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_last_bgsave_status"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Status of the last RDB save operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_last_bgsave_time_sec"}),(0,n.jsx)(t.td,{children:"second"}),(0,n.jsx)(t.td,{children:"Duration of the last RDB save operation in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_current_bgsave_time_sec"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Duration of the on-going RDB save operation if any"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rdb_last_cow_size"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The size in bytes of copy-on-write memory during the last RDB save operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_enabled"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating AOF logging is activated"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_rewrite_in_progress"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating a AOF rewrite operation is on-going"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_rewrite_scheduled"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating an AOF rewrite operation will be scheduled once the on-going RDB save is complete."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_last_rewrite_time_sec"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Duration of the last AOF rewrite operation in seconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_current_rewrite_time_sec"}),(0,n.jsx)(t.td,{children:"second"}),(0,n.jsx)(t.td,{children:"Duration of the on-going AOF rewrite operation if any"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_last_bgrewrite_status"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Status of the last AOF rewrite operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_last_write_status"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Status of the last write operation to the AOF"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"aof_last_cow_size"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The size in bytes of copy-on-write memory during the last AOF rewrite operation"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"module_fork_in_progress"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating a module fork is on-going"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"module_fork_last_cow_size"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The size in bytes of copy-on-write memory during the last module fork operation"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setstats",children:"Metric set\uff1astats"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_connections_received"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of connections accepted by the server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_commands_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of commands processed by the server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"instantaneous_ops_per_sec"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of commands processed per second"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_net_input_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The total number of bytes read from the network"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_net_output_bytes"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"The total number of bytes written to the network"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"instantaneous_input_kbps"}),(0,n.jsx)(t.td,{children:"KB/S"}),(0,n.jsx)(t.td,{children:"The network's read rate per second in KB/sec"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"instantaneous_output_kbps"}),(0,n.jsx)(t.td,{children:"KB/S"}),(0,n.jsx)(t.td,{children:"The network's write rate per second in KB/sec"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"rejected_connections"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of connections rejected because of maxclients limit"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"sync_full"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of full resyncs with replicas"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"sync_partial_ok"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of accepted partial resync requests"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"sync_partial_err"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of denied partial resync requests"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"expired_keys"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of key expiration events"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"expired_stale_perc"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The percentage of keys probably expired"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"expired_time_cap_reached_count"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The count of times that active expiry cycles have stopped early"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"expire_cycle_cpu_milliseconds"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The cumulative amount of time spent on active expiry cycles"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"evicted_keys"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of evicted keys due to maxmemory limit"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"keyspace_hits"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of successful lookup of keys in the main dictionary"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"keyspace_misses"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of failed lookup of keys in the main dictionary"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"pubsub_channels"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Global number of pub/sub channels with client subscriptions"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"pubsub_patterns"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Global number of pub/sub pattern with client subscriptions"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"latest_fork_usec"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Duration of the latest fork operation in microseconds"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_forks"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of fork operations since the server start"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"migrate_cached_sockets"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of sockets open for MIGRATE purposes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"slave_expires_tracked_keys"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The number of keys tracked for expiry purposes (applicable only to writable replicas)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"active_defrag_hits"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of value reallocations performed by active the defragmentation process"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"active_defrag_misses"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of aborted value reallocations started by the active defragmentation process"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"active_defrag_key_hits"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of keys that were actively defragmented"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"active_defrag_key_misses"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of keys that were skipped by the active defragmentation process"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"tracking_total_keys"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of keys being tracked by the server"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"tracking_total_items"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of items, that is the sum of clients number for each key, that are being tracked"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"tracking_total_prefixes"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of tracked prefixes in server's prefix table (only applicable for broadcast mode)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"unexpected_error_replies"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of unexpected error replies, that are types of errors from an AOF load or replication"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_error_replies"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of issued error replies, that is the sum of rejected commands (errors prior command execution) and failed commands (errors within the command execution)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"dump_payload_sanitizations"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of dump payload deep integrity validations (see sanitize-dump-payload config)."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_reads_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of read events processed"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"total_writes_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Total number of write events processed"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"io_threaded_reads_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of read events processed by the main and I/O threads"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"io_threaded_writes_processed"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of write events processed by the main and I/O threads"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setreplication",children:"Metric set\uff1areplication"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"role"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:'Value is "master" if the instance is replica of no one, or "slave" if the instance is a replica of some master instance. Note that a replica can be master of another replica (chained replication).'})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"connected_slaves"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Number of connected replicas"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"master_failover_state"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The state of an ongoing failover, if any."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"master_replid"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The replication ID of the Valkey server."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"master_replid2"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The secondary replication ID, used for PSYNC after a failover."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"master_repl_offset"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The server's current replication offset"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"second_repl_offset"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The offset up to which replication IDs are accepted"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"repl_backlog_active"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Flag indicating replication backlog is active"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"repl_backlog_size"}),(0,n.jsx)(t.td,{children:"byte"}),(0,n.jsx)(t.td,{children:"Total size in bytes of the replication backlog buffer"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"repl_backlog_first_byte_offset"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"The master offset of the replication backlog buffer"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"repl_backlog_histlen"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Size in bytes of the data in the replication backlog buffer"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setcpu",children:"Metric set\uff1acpu"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_sys"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"System CPU consumed by the Valkey server, which is the sum of system CPU consumed by all threads of the server process (main thread and background threads)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_user"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"User CPU consumed by the Valkey server, which is the sum of user CPU consumed by all threads of the server process (main thread and background threads)"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_sys_children"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"System CPU consumed by the background processes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_user_children"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"User CPU consumed by the background processes"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_sys_main_thread"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"System CPU consumed by the Valkey server main thread"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"used_cpu_user_main_thread"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"User CPU consumed by the Valkey server main thread"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-seterrorstats",children:"Metric set\uff1aerrorstats"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"errorstat_ERR"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"ERR count"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"errorstat_MISCONF"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"MISCONF count"})]})]})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setcluster",children:"Metric set\uff1acluster"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsx)(t.tbody,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cluster_enabled"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"Indicate Valkey cluster is enabled"})]})})]}),"\n",(0,n.jsx)(t.h4,{id:"metric-setcommandstats",children:"Metric set\uff1acommandstats"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Metric name"}),(0,n.jsx)(t.th,{children:"Metric unit"}),(0,n.jsx)(t.th,{children:"Metric help description"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_set"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"set command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_get"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"get command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_setnx"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"setnx command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_hset"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"hset command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_hget"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"hget command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_lpush"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"lpush command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_rpush"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"rpush command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_lpop"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"lpop command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_rpop"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"rpop command stat"})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"cmdstat_llen"}),(0,n.jsx)(t.td,{children:"none"}),(0,n.jsx)(t.td,{children:"llen command stat"})]})]})]})]})}function a(e={}){const{wrapper:t}={...(0,d.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(o,{...e})}):o(e)}},60056(e,t,r){r.d(t,{R:()=>i,x:()=>c});var s=r(30758);const n={},d=s.createContext(n);function i(e){const t=s.useContext(d);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:i(e.components),s.createElement(d.Provider,{value:t},e.children)}}}]);